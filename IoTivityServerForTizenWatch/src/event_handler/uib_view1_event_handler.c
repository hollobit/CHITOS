/*******************************************************************************
* This file was generated by UI Builder.
* User should hand edit this file.
********************************************************************************/

#include "app_main.h"
#include "uib_views.h"
#include "uib_views_inc.h"
#include <sensor.h>
#include "../resource/common.h"

typedef struct _uib_view1_control_context {
 /* add your variables here */

} uib_view1_control_context;

sensor_type_e type = SENSOR_HRM;
sensor_h sensor;
sensor_listener_h listener;
uib_view1_view_context *_vc;
bool bStarted = true;
bool isFirst = true;

void on_sensor_event(sensor_h sensor, sensor_event_s *event, void *user_data){
    // Select a specific sensor with a sensor handle
    sensor_type_e type;
    sensor_get_type(sensor, &type);

    switch (type) {
    case SENSOR_HRM:
    	dlog_print(DLOG_INFO, LOG_TAG, "%d" , event->values[0]);
        setLastHrmValue(getHrmValue());
    	setHrmValue((int)event->values[0]);
    	char a[100];
    	sprintf(a,"<align='center'>Heartrate:%d</align>", getHrmValue());
    	elm_object_text_set(_vc->lblheartrate, a);
    	break;
    default:
        dlog_print(DLOG_ERROR, LOG_TAG, "Not an HRM event");
    }
}

void _sensor_accuracy_changed_cb(sensor_h sensor, unsigned long long timestamp,
                                 sensor_data_accuracy_e accuracy, void *data)
{
    dlog_print(DLOG_DEBUG, LOG_TAG, "Sensor accuracy change callback invoked");
}

void hrm_start(uib_view1_view_context *vc) {
	char out[100] = {0x00, };
	bool supported;
	int error = sensor_is_supported(type, &supported);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_is_supported error: %d", error);
		return;
	}

	if(supported){
		dlog_print(DLOG_DEBUG, LOG_TAG, "HRM is%s supported", supported ? "" : " not");
	}

	// Get sensor list
	int count;
	sensor_h *list;

	error = sensor_get_sensor_list(type, &list, &count);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_sensor_list error: %d", error);
	} else {
		dlog_print(DLOG_DEBUG, LOG_TAG, "Number of sensors: %d", count);
		free(list);
	}

	error = sensor_get_default_sensor(type, &sensor);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_default_sensor error: %d", error);
		return;
	}

	dlog_print(DLOG_DEBUG, LOG_TAG, "sensor_get_default_sensor");

	// creating an event listener
	error = sensor_create_listener(sensor, &listener);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_create_listener error: %d",error);
		return;
	}

	int min_interval = 0;
	error = sensor_get_min_interval(sensor, &min_interval);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_min_interval error: %d", error);
		return;
	}

	// Callback for sensor value change
	void *user_data = NULL;
	error = sensor_listener_set_event_cb(listener, min_interval, on_sensor_event, user_data);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_set_event_cb error: %d", error);
		return;
	}

	// Registering the Accuracy Changed Callback
	error = sensor_listener_set_accuracy_cb(listener, _sensor_accuracy_changed_cb, user_data);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_set_accuracy_cb error: %d", error);
		return;
	}

	error = sensor_listener_set_interval(listener, 100);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_set_interval error: %d", error);
		return;
	}

	error = sensor_listener_set_option(listener, SENSOR_OPTION_ALWAYS_ON);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_set_option error: %d", error);
		return;
	}

	error = sensor_listener_start(listener);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_start error: %d", error);
		return;
	}
	elm_object_text_set(vc->button1, "Stop");

	dlog_print(DLOG_DEBUG, LOG_TAG, "sensor_listener_start");

	sensor_event_s event;
	error = sensor_listener_read_data(listener, &event);
	if (error != SENSOR_ERROR_NONE) {

		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_read_data error: %d", error);
		return;
	}

	switch (type) {

	case SENSOR_HRM:
		dlog_print(DLOG_INFO, LOG_TAG, "%f" , event.values[0]);
		setHrmValue((int)event.values[0]);
		sprintf(out,"<align='center'>Heartrate:%d</align>", getHrmValue());
		elm_object_text_set(_vc->lblheartrate, out);
		break;
	default:
		dlog_print(DLOG_ERROR, LOG_TAG, "Not an HRM event");
	}


	char *name = NULL;
	char *vendor = NULL;
	float min_range = 0.0;
	float max_range = 220.0;
	float resolution = 0.0;

	error = sensor_get_name(sensor, &name);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_name error: %d", error);
		return;
	}

	dlog_print(DLOG_DEBUG, LOG_TAG, "Sensor name: %s", name);
	free(name);

	error = sensor_get_vendor(sensor, &vendor);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_vendor error: %d", error);
		return;
	}


	dlog_print(DLOG_DEBUG, LOG_TAG, "Sensor vendor: %s", vendor);
	free(vendor);

	error = sensor_get_type(sensor, &type);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_type error: %d", error);
		return;
	}

	dlog_print(DLOG_DEBUG, LOG_TAG, "Sensor type: %s",
			type == SENSOR_ACCELEROMETER               ? "Accelerometer"
		  : type == SENSOR_GRAVITY                     ? "Gravity sensor"
		  : type == SENSOR_LINEAR_ACCELERATION         ? "Linear acceleration sensor"
		  : type == SENSOR_MAGNETIC                    ? "Magnetic sensor"
		  : type == SENSOR_ROTATION_VECTOR             ? "Rotation Vector sensor"
		  : type == SENSOR_ORIENTATION                 ? "Orientation sensor"
		  : type == SENSOR_GYROSCOPE                   ? "Gyroscope sensor"
		  : type == SENSOR_LIGHT                       ? "Light sensor"
		  : type == SENSOR_PROXIMITY                   ? "Proximity sensor"
		  : type == SENSOR_PRESSURE                    ? "Pressure sensor"
		  : type == SENSOR_ULTRAVIOLET                 ? "Ultraviolet sensor"
		  : type == SENSOR_TEMPERATURE                 ? "Temperature sensor"
		  : type == SENSOR_HUMIDITY                    ? "Humidity sensor"
		  : type == SENSOR_HRM                         ? "Heart Rate Monitor sensor (Since Tizen 2.3.1)"
		  : type == SENSOR_HRM_LED_GREEN               ? "HRM (LED Green) sensor (Since Tizen 2.3.1)"
		  : type == SENSOR_HRM_LED_IR                  ? "HRM (LED IR) sensor (Since Tizen 2.3.1)"
		  : type == SENSOR_HRM_LED_RED                 ? "HRM (LED RED) sensor (Since Tizen 2.3.1)"
		  : type == SENSOR_LAST                        ? "End of sensor enum values" : "Custom sensor");

	error = sensor_get_min_range(sensor, &min_range);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_min_range error: %d", error);
		return;
	}

	dlog_print(DLOG_DEBUG, LOG_TAG, "Minimum range of the sensor: %f", min_range);

	error = sensor_get_max_range(sensor, &max_range);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_max_range error: %d", error);
		return;
	}

	dlog_print(DLOG_DEBUG, LOG_TAG, "Maximum range of the sensor: %f", max_range);

	error = sensor_get_resolution(sensor, &resolution);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_get_resolution error: %d", error);
		return;
	}

	dlog_print(DLOG_DEBUG, LOG_TAG, "Resolution of the sensor: %f", resolution);


}

void hrm_stop(uib_view1_view_context *vc) {
	int error = sensor_listener_unset_event_cb(listener);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_unset_event_cb error: %d", error);
	}

	error = sensor_listener_stop(listener);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_listener_stop error: %d", error);
	}

	error = sensor_destroy_listener(listener);
	if (error != SENSOR_ERROR_NONE) {
		dlog_print(DLOG_ERROR, LOG_TAG, "sensor_destroy_listener error: %d", error);
	}

	elm_object_text_set(vc->button1, "Refresh");
}

Eina_Bool
_time_cb(void *data)
{
	char * _time_str = (char*)malloc(9);
	memset(_time_str, 0x00, 9);
	_getCurrentTime(_time_str);
	char time_str[255] = {0x00, };
	sprintf(time_str,"<align='center'>%s</align>", _time_str);
	free(_time_str);

	elm_object_text_set(_vc->lblTime, time_str);

    return ECORE_CALLBACK_RENEW;

    //return ECORE_CALLBACK_CANCEL;
}




void view1_button1_onclicked(uib_view1_view_context *vc, Evas_Object *obj, void *event_info) {
	dlog_print(DLOG_INFO, LOG_TAG, "button pressed... 버튼 눌림.");

	bStarted = !bStarted;
	_vc = vc;

	if(isFirst) {
		isFirst = false;
		ecore_timer_add(0.1, _time_cb, NULL);
	}

	if(!bStarted) {
		elm_object_text_set(vc->lblheartrate, "<align='center'>Heartrate:Cheking...</align>");
		hrm_start(vc);
	} else {
		elm_object_text_set(vc->lblheartrate, "<align='center'>Heartrate:Stopped...</align>");
		hrm_stop(vc);
	}

}

