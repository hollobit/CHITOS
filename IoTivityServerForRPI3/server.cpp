#include "iotivity_config.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_WINDOWS_H
#include <windows.h>
#endif
#include <signal.h>
#ifdef HAVE_PTHREAD_H
#include <pthread.h>
#endif
#include "ocstack.h"
#include "logger.h"
#include "server.h"

#if USE_HW
#include "./MySignals/controlboard.h"
#endif

#define TAG "SERVER"

int gQuitFlag = 0;
static char CRED_FILE[] = "server.dat";

/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
void handleSigInt(int signum)
{
    if (signum == SIGINT)
    {
        gQuitFlag = 1;
    }
}

FILE* server_fopen(const char *path, const char *mode)
{
    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
    {
        return fopen(CRED_FILE, mode);
    }
    else
    {
        return fopen(path, mode);
    }
}
// 쓰레드 함수
#if USE_HW
void *t_function(void *data)
{
    pid_t pid;            // process id
    pthread_t tid;        // thread id
 
    pid = getpid();
    tid = pthread_self();
 
    char* thread_name = (char*)data;
    int i = 0;

    struct timespec timeout;
    
    timeout.tv_sec  = 0;
    timeout.tv_nsec = 100000000L;
    signal(SIGINT, handleSigInt);
    while (!gQuitFlag)   // 0,1,2 까지만 loop 돌립니다.
    {
        // 넘겨받은 쓰레드 이름과 
        // 현재 process id 와 thread id 를 함께 출력
        // printf("[%s] pid:%u, tid:%x --- %d\n", 
        //     thread_name, (unsigned int)pid, (unsigned int)tid, i);
        // i++;
        runControlBoardMainLoop();
        nanosleep(&timeout, NULL); // 1초간 대기
    }
}
#endif
void *iotivityThread(void *data) {
    struct timespec timeout;

    timeout.tv_sec  = 0;
    timeout.tv_nsec = 100000000L;

    // Break from loop with Ctrl-C
    OIC_LOG(INFO, TAG, "Entering ocserver main loop...");
    signal(SIGINT, handleSigInt);
    while (!gQuitFlag)
    {
        if (OCProcess() != OC_STACK_OK)
        {
            OIC_LOG(ERROR, TAG, "OCStack process error");
            return 0;
        }
        nanosleep(&timeout, NULL);
    }

    OIC_LOG(INFO, TAG, "Exiting ocserver main loop...");

    if (OCStop() != OC_STACK_OK)
    {
        OIC_LOG(ERROR, TAG, "OCStack process error");
    }
}

#if USE_HW
void *blinkThread(void *data) {
    struct timespec timeout;
    timeout.tv_sec  = 0;
    timeout.tv_nsec = 100000000L;

    signal(SIGINT, handleSigInt);
    while(!gQuitFlag) {
        if(isRunBlink()>0) {
            blinkLed();            
        }
        nanosleep(&timeout, NULL);
    }
}
#endif

// Platform Info
/**
 * This structure describes the platform properties. All non-Null properties will be
 * included in a platform discovery request.
 * @deprecated: Use OCSetPropertyValue  to set platform value.
 */
const char *gPlatformID = "12341234-1234-1234-1234-123412341234";
const char *gManufacturerName = "Electronics and Telecommunications Research Institute";
const char *gManufacturerLink = "https://www.etri.re.kr";
const char *gModelNumber = "myModelNumber";
const char *gDateOfManufacture = "2017-11-09";
const char *gPlatformVersion = "1.0";
const char *gOperatingSystemVersion = "Linux raspberrypi 4.9.35 armv7l GNU/Linux";
const char *gHardwareVersion = "RaspberryPi 3 Model B/ MySignals V2.0";
const char *gFirmwareVersion = "1.0";
const char *gSupportLink = "https://www.etri.re.kr";
const char *gSystemTime = "2015-05-15T11.04";

// Device Info
/**
 * This structure is expected as input for device properties.
 * device name is mandatory and expected from the application.
 * device id of type UUID will be generated by the stack.
 * @deprecated: Use OCSetPropertyValue  to set device value.
 */
// Thermometer
const char *gDeviceTypeBodyThermometer = "oic.d.bodythermometer";
const char *gDeviceNameBodyThermometer = "Thermometer";
// Blood Pressure Monitor
const char *gDeviceTypeBloodPressure = "oic.d.bloodpressuremonitor";
const char *gDeviceNameBloodPressure = "Blood Pressure Monitor";
// Glucose Meter
const char *gDeviceTypeGlucose = "oic.d.glucosemeter";
const char *gDeviceNameGlucose = "Glucose Meter";
// Scale
const char *gDeviceTypeScale = "oic.d.bodyscale";
const char *gDeviceNameScale = "Scale";
const char *gSpecVersion = "ocf.1.1.0";
const char *gDataModelVersions = "ocf.res.1.1.0,ocf.sh.1.1.0";
const char *gProtocolIndependentID = "12341234-1234-1234-1234-123412341234";

OCPlatformInfo platformInfo;

void DeletePlatformInfo()
{
    free(platformInfo.platformID);
    free(platformInfo.manufacturerName);
    free(platformInfo.manufacturerUrl);
    free(platformInfo.modelNumber);
    free(platformInfo.dateOfManufacture);
    free(platformInfo.platformVersion);
    free(platformInfo.operatingSystemVersion);
    free(platformInfo.hardwareVersion);
    free(platformInfo.firmwareVersion);
    free(platformInfo.supportUrl);
    free(platformInfo.systemTime);
}

bool DuplicateString(char** targetString, const char* sourceString)
{
    if(!sourceString)
    {
        return false;
    }
    else
    {
        *targetString = (char *) malloc(strlen(sourceString) + 1);

        if(*targetString)
        {
            strncpy(*targetString, sourceString, (strlen(sourceString) + 1));
            return true;
        }
    }
    return false;
}

OCStackResult SetPlatformInfo(const char* platformID, const char *manufacturerName,
    const char *manufacturerUrl, const char *modelNumber, const char *dateOfManufacture,
    const char *platformVersion, const char* operatingSystemVersion, const char* hardwareVersion,
    const char *firmwareVersion, const char* supportUrl, const char* systemTime)
{

    bool success = true;

    if(manufacturerName != NULL && (strlen(manufacturerName) > MAX_PLATFORM_NAME_LENGTH))
    {
        return OC_STACK_INVALID_PARAM;
    }

    if(manufacturerUrl != NULL && (strlen(manufacturerUrl) > MAX_PLATFORM_URL_LENGTH))
    {
        return OC_STACK_INVALID_PARAM;
    }

    if(!DuplicateString(&platformInfo.platformID, platformID))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.manufacturerName, manufacturerName))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.manufacturerUrl, manufacturerUrl))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.modelNumber, modelNumber))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.dateOfManufacture, dateOfManufacture))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.platformVersion, platformVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.operatingSystemVersion, operatingSystemVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.hardwareVersion, hardwareVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.firmwareVersion, firmwareVersion))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.supportUrl, supportUrl))
    {
        success = false;
    }

    if(!DuplicateString(&platformInfo.systemTime, systemTime))
    {
        success = false;
    }

    if(success)
    {
        return OC_STACK_OK;
    }

    DeletePlatformInfo();
    return OC_STACK_ERROR;
}

#define VERIFY_SUCCESS(op)                          \
{                                                   \
    if (op !=  OC_STACK_OK)                         \
    {                                               \
        OIC_LOG_V(FATAL, TAG, "%s failed!!", #op);  \
        goto exit;                                  \
    }                                               \
}

OCStackResult SetDeviceInfo(char c)
{
    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
    if (resourceHandle == NULL)
    {
        OIC_LOG(ERROR, TAG, "Device Resource does not exist.");
        goto exit;
    }

    if(c == 'T') {
        VERIFY_SUCCESS(OCBindResourceTypeToResource(resourceHandle, gDeviceTypeBodyThermometer));
        VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceNameBodyThermometer));
    } else if(c == 'P') {
        VERIFY_SUCCESS(OCBindResourceTypeToResource(resourceHandle, gDeviceTypeBloodPressure));
        VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceNameBloodPressure));
    } else if(c == 'G') {
        VERIFY_SUCCESS(OCBindResourceTypeToResource(resourceHandle, gDeviceTypeGlucose));
        VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceNameGlucose));
    } else if(c == 'S') {
        VERIFY_SUCCESS(OCBindResourceTypeToResource(resourceHandle, gDeviceTypeScale));
        VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceNameScale));
    }
    
    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, gSpecVersion));
    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION,
                                      gDataModelVersions));
    VERIFY_SUCCESS(OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID,
                                      gProtocolIndependentID));

    if(c == 'T') {
        OIC_LOG(INFO, TAG, "Device information(Thermometer) initialized successfully.");
    } else if(c == 'P') {
        OIC_LOG(INFO, TAG, "Device information(Blood Pressure Monitor) initialized successfully.");
    } else if(c == 'G') {
        OIC_LOG(INFO, TAG, "Device information(Glucose Meter) initialized successfully.");
    } else if(c == 'S') {
        OIC_LOG(INFO, TAG, "Device information(Scale) initialized successfully.");
    }
    
    return OC_STACK_OK;

exit:
    return OC_STACK_ERROR;
}

int main(int argc, char* argv[])
{
    OIC_LOG(DEBUG, TAG, "OCServer is starting...");

    char command = 'T';

    if(argc > 1) {
        if(strcmp(argv[1], "t") == 0 || strcmp(argv[1], "T") == 0) {
            command = 'T';
        } else if(strcmp(argv[1], "p") == 0 || strcmp(argv[1], "P") == 0) {
            command = 'P';
        } else if(strcmp(argv[1], "g") == 0 || strcmp(argv[1], "G") == 0) {
            command = 'G';
        } else if(strcmp(argv[1], "s") == 0 || strcmp(argv[1], "S") == 0) {
            command = 'S';
        }
    }
    
#if IS_SECURE_MODE
    // Initialize Persistent Storage for SVR database
    OCPersistentStorage ps = { server_fopen, fread, fwrite, fclose, unlink };
    OCRegisterPersistentStorageHandler(&ps);
#endif

    if (OCInit(NULL, 0, OC_SERVER) != OC_STACK_OK)
    {
        OIC_LOG(ERROR, TAG, "OCStack init error");
        return 0;
    }

    OCStackResult registrationResult =
    SetPlatformInfo(gPlatformID, gManufacturerName, gManufacturerLink, gModelNumber,
                    gDateOfManufacture, gPlatformVersion, gOperatingSystemVersion,
                    gHardwareVersion, gFirmwareVersion, gSupportLink, gSystemTime);
    if (registrationResult != OC_STACK_OK)
    {
        OIC_LOG(INFO, TAG, "Platform info setting failed locally!");
        exit (EXIT_FAILURE);
    }

    registrationResult = OCSetPlatformInfo(platformInfo);    
    if (registrationResult != OC_STACK_OK)
    {
        OIC_LOG(INFO, TAG, "Platform Registration failed!");
        exit (EXIT_FAILURE);
    } else {
        OIC_LOG(INFO, TAG, "Platform information initialized successfully.");
    }

    registrationResult = SetDeviceInfo(command);
    if (registrationResult != OC_STACK_OK)
    {
        OIC_LOG(INFO, TAG, "Device Registration failed!");
        exit (EXIT_FAILURE);
    }

    /*
     * Declare and create the example resource: LED
     */
    if(command == 'T') {
        createTemp0Resource();
        createTemp4Resource();
        createTemp5Resource();
        createUserIdResource("temperature_unique_example_id", "temperature_OCF2017");
        createClockResource("temperature_unique_example_id");
    } else if(command == 'P') {
        createBP0Resource();
        createBP1Resource();
        createBP2Resource();
        createUserIdResource("bloodpressure_unique_example_id", "bloodpressure_OCF2017");
        createClockResource("bloodpressure_unique_example_id");
    } else if(command == 'G') {
        createGlucose0Resource();
        createGlucose1Resource();
        createGlucose2Resource();
        createGlucose3Resource();
        createGlucose4Resource();
        createGlucose5Resource();
        createGlucose6Resource();
        createGlucose7Resource();
        createGlucose8Resource();
        createGlucose9Resource();
        createGlucose10Resource();
        createUserIdResource("glucose_unique_example_id", "glucose_OCF2017");
        createClockResource("glucose_unique_example_id");
    } else if(command == 'S') {
        createScale0Resource();
        createScale1Resource();
        createScale2Resource();
        createScale3Resource();
        createScale4Resource();
        createScale5Resource();
        createScale6Resource();
        createScale7Resource();
        createScale8Resource(); // [CUSTOM RESOURCE] : kr.re.etri.r.userinfo, /UserInfoResURI
        createUserIdResource("scale_unique_example_id", "scale_OCF2017");
        createClockResource("scale_unique_example_id");
    }
    

    int status;
    pthread_t p_thread[3];
    int thread_id;

#if USE_HW
    setupControlBoard(command);

    char p1[] = "thread_1";
    thread_id = pthread_create(&p_thread[0], NULL, t_function, (void *)p1);
    if (thread_id < 0)
    {
        perror("thread create error : ");
        exit(0);
    }
#endif

    char p2[] = "iotivity_thread";
    thread_id = pthread_create(&p_thread[1], NULL, iotivityThread, (void *)p2);
    if (thread_id < 0)
    {
        perror("thread create error : ");
        exit(0);
    }

#if USE_HW
    char p3[] = "blink_thread";
    thread_id = pthread_create(&p_thread[2], NULL, blinkThread, (void*)p3);
    if (thread_id < 0)
    {
        perror("blink thread create error : ");
        exit(0);
    }
#endif

#if USE_HW
    pthread_join(p_thread[0], (void **)&status);
#endif
    pthread_join(p_thread[1], (void **)&status);
#if USE_HW
    pthread_join(p_thread[2], (void **)&status);
#endif

    return 0;
}